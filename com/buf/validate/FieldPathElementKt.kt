// Generated by the protocol buffer compiler. DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: buf/validate/validate.proto

@file:com.google.protobuf.Generated
// Generated files should ignore deprecation warnings
@file:Suppress("DEPRECATION")
package com.buf.validate;

@kotlin.jvm.JvmName("-initializefieldPathElement")
public inline fun fieldPathElement(block: com.buf.validate.FieldPathElementKt.Dsl.() -> kotlin.Unit): com.buf.validate.FieldPathElement =
  com.buf.validate.FieldPathElementKt.Dsl._create(com.buf.validate.FieldPathElement.newBuilder()).apply { block() }._build()
/**
 * ```
 * `FieldPathElement` provides enough information to nest through a single protobuf field.
 *
 * If the selected field is a map or repeated field, the `subscript` value selects a specific element from it.
 * A path that refers to a value nested under a map key or repeated field index will have a `subscript` value.
 * The `field_type` field allows unambiguous resolution of a field even if descriptors are not available.
 * ```
 *
 * Protobuf type `buf.validate.FieldPathElement`
 */
public object FieldPathElementKt {
  @kotlin.OptIn(com.google.protobuf.kotlin.OnlyForUseByGeneratedProtoCode::class)
  @com.google.protobuf.kotlin.ProtoDslMarker
  public class Dsl private constructor(
    private val _builder: com.buf.validate.FieldPathElement.Builder
  ) {
    public companion object {
      @kotlin.jvm.JvmSynthetic
    @kotlin.PublishedApi
      internal fun _create(builder: com.buf.validate.FieldPathElement.Builder): Dsl = Dsl(builder)
    }

    @kotlin.jvm.JvmSynthetic
  @kotlin.PublishedApi
    internal fun _build(): com.buf.validate.FieldPathElement = _builder.build()

    /**
     * ```
     * `field_number` is the field number this path element refers to.
     * ```
     *
     * `optional int32 field_number = 1 [json_name = "fieldNumber"];`
     */
    public var fieldNumber: kotlin.Int
      @kotlin.jvm.JvmName("getFieldNumber")
        get() = _builder.fieldNumber
      @kotlin.jvm.JvmName("setFieldNumber")
        set(value) {
        _builder.fieldNumber = value
      }
    /**
     * ```
     * `field_number` is the field number this path element refers to.
     * ```
     *
     * `optional int32 field_number = 1 [json_name = "fieldNumber"];`
     */
    public fun clearFieldNumber() {
      _builder.clearFieldNumber()
    }
    /**
     * ```
     * `field_number` is the field number this path element refers to.
     * ```
     *
     * `optional int32 field_number = 1 [json_name = "fieldNumber"];`
     * @return Whether the fieldNumber field is set.
     */
    public fun hasFieldNumber(): kotlin.Boolean {
      return _builder.hasFieldNumber()
    }

    /**
     * ```
     * `field_name` contains the field name this path element refers to.
     * This can be used to display a human-readable path even if the field number is unknown.
     * ```
     *
     * `optional string field_name = 2 [json_name = "fieldName"];`
     */
    public var fieldName: kotlin.String
      @kotlin.jvm.JvmName("getFieldName")
        get() = _builder.fieldName
      @kotlin.jvm.JvmName("setFieldName")
        set(value) {
        _builder.fieldName = value
      }
    /**
     * ```
     * `field_name` contains the field name this path element refers to.
     * This can be used to display a human-readable path even if the field number is unknown.
     * ```
     *
     * `optional string field_name = 2 [json_name = "fieldName"];`
     */
    public fun clearFieldName() {
      _builder.clearFieldName()
    }
    /**
     * ```
     * `field_name` contains the field name this path element refers to.
     * This can be used to display a human-readable path even if the field number is unknown.
     * ```
     *
     * `optional string field_name = 2 [json_name = "fieldName"];`
     * @return Whether the fieldName field is set.
     */
    public fun hasFieldName(): kotlin.Boolean {
      return _builder.hasFieldName()
    }

    /**
     * ```
     * `field_type` specifies the type of this field. When using reflection, this value is not needed.
     *
     * This value is provided to make it possible to traverse unknown fields through wire data.
     * When traversing wire data, be mindful of both packed[1] and delimited[2] encoding schemes.
     *
     * [1]: https://protobuf.dev/programming-guides/encoding/#packed
     * [2]: https://protobuf.dev/programming-guides/encoding/#groups
     *
     * N.B.: Although groups are deprecated, the corresponding delimited encoding scheme is not, and
     * can be explicitly used in Protocol Buffers 2023 Edition.
     * ```
     *
     * `optional .google.protobuf.FieldDescriptorProto.Type field_type = 3 [json_name = "fieldType"];`
     */
    public var fieldType: com.google.protobuf.DescriptorProtos.FieldDescriptorProto.Type
      @kotlin.jvm.JvmName("getFieldType")
        get() = _builder.fieldType
      @kotlin.jvm.JvmName("setFieldType")
        set(value) {
        _builder.fieldType = value
      }
    /**
     * ```
     * `field_type` specifies the type of this field. When using reflection, this value is not needed.
     *
     * This value is provided to make it possible to traverse unknown fields through wire data.
     * When traversing wire data, be mindful of both packed[1] and delimited[2] encoding schemes.
     *
     * [1]: https://protobuf.dev/programming-guides/encoding/#packed
     * [2]: https://protobuf.dev/programming-guides/encoding/#groups
     *
     * N.B.: Although groups are deprecated, the corresponding delimited encoding scheme is not, and
     * can be explicitly used in Protocol Buffers 2023 Edition.
     * ```
     *
     * `optional .google.protobuf.FieldDescriptorProto.Type field_type = 3 [json_name = "fieldType"];`
     */
    public fun clearFieldType() {
      _builder.clearFieldType()
    }
    /**
     * ```
     * `field_type` specifies the type of this field. When using reflection, this value is not needed.
     *
     * This value is provided to make it possible to traverse unknown fields through wire data.
     * When traversing wire data, be mindful of both packed[1] and delimited[2] encoding schemes.
     *
     * [1]: https://protobuf.dev/programming-guides/encoding/#packed
     * [2]: https://protobuf.dev/programming-guides/encoding/#groups
     *
     * N.B.: Although groups are deprecated, the corresponding delimited encoding scheme is not, and
     * can be explicitly used in Protocol Buffers 2023 Edition.
     * ```
     *
     * `optional .google.protobuf.FieldDescriptorProto.Type field_type = 3 [json_name = "fieldType"];`
     * @return Whether the fieldType field is set.
     */
    public fun hasFieldType(): kotlin.Boolean {
      return _builder.hasFieldType()
    }

    /**
     * ```
     * `key_type` specifies the map key type of this field. This value is useful when traversing
     * unknown fields through wire data: specifically, it allows handling the differences between
     * different integer encodings.
     * ```
     *
     * `optional .google.protobuf.FieldDescriptorProto.Type key_type = 4 [json_name = "keyType"];`
     */
    public var keyType: com.google.protobuf.DescriptorProtos.FieldDescriptorProto.Type
      @kotlin.jvm.JvmName("getKeyType")
        get() = _builder.keyType
      @kotlin.jvm.JvmName("setKeyType")
        set(value) {
        _builder.keyType = value
      }
    /**
     * ```
     * `key_type` specifies the map key type of this field. This value is useful when traversing
     * unknown fields through wire data: specifically, it allows handling the differences between
     * different integer encodings.
     * ```
     *
     * `optional .google.protobuf.FieldDescriptorProto.Type key_type = 4 [json_name = "keyType"];`
     */
    public fun clearKeyType() {
      _builder.clearKeyType()
    }
    /**
     * ```
     * `key_type` specifies the map key type of this field. This value is useful when traversing
     * unknown fields through wire data: specifically, it allows handling the differences between
     * different integer encodings.
     * ```
     *
     * `optional .google.protobuf.FieldDescriptorProto.Type key_type = 4 [json_name = "keyType"];`
     * @return Whether the keyType field is set.
     */
    public fun hasKeyType(): kotlin.Boolean {
      return _builder.hasKeyType()
    }

    /**
     * ```
     * `value_type` specifies map value type of this field. This is useful if you want to display a
     * value inside unknown fields through wire data.
     * ```
     *
     * `optional .google.protobuf.FieldDescriptorProto.Type value_type = 5 [json_name = "valueType"];`
     */
    public var valueType: com.google.protobuf.DescriptorProtos.FieldDescriptorProto.Type
      @kotlin.jvm.JvmName("getValueType")
        get() = _builder.valueType
      @kotlin.jvm.JvmName("setValueType")
        set(value) {
        _builder.valueType = value
      }
    /**
     * ```
     * `value_type` specifies map value type of this field. This is useful if you want to display a
     * value inside unknown fields through wire data.
     * ```
     *
     * `optional .google.protobuf.FieldDescriptorProto.Type value_type = 5 [json_name = "valueType"];`
     */
    public fun clearValueType() {
      _builder.clearValueType()
    }
    /**
     * ```
     * `value_type` specifies map value type of this field. This is useful if you want to display a
     * value inside unknown fields through wire data.
     * ```
     *
     * `optional .google.protobuf.FieldDescriptorProto.Type value_type = 5 [json_name = "valueType"];`
     * @return Whether the valueType field is set.
     */
    public fun hasValueType(): kotlin.Boolean {
      return _builder.hasValueType()
    }

    /**
     * ```
     * `index` specifies a 0-based index into a repeated field.
     * ```
     *
     * `uint64 index = 6 [json_name = "index"];`
     */
    public var index: kotlin.Long
      @kotlin.jvm.JvmName("getIndex")
        get() = _builder.index
      @kotlin.jvm.JvmName("setIndex")
        set(value) {
        _builder.index = value
      }
    /**
     * ```
     * `index` specifies a 0-based index into a repeated field.
     * ```
     *
     * `uint64 index = 6 [json_name = "index"];`
     */
    public fun clearIndex() {
      _builder.clearIndex()
    }
    /**
     * ```
     * `index` specifies a 0-based index into a repeated field.
     * ```
     *
     * `uint64 index = 6 [json_name = "index"];`
     * @return Whether the index field is set.
     */
    public fun hasIndex(): kotlin.Boolean {
      return _builder.hasIndex()
    }

    /**
     * ```
     * `bool_key` specifies a map key of type bool.
     * ```
     *
     * `bool bool_key = 7 [json_name = "boolKey"];`
     */
    public var boolKey: kotlin.Boolean
      @kotlin.jvm.JvmName("getBoolKey")
        get() = _builder.boolKey
      @kotlin.jvm.JvmName("setBoolKey")
        set(value) {
        _builder.boolKey = value
      }
    /**
     * ```
     * `bool_key` specifies a map key of type bool.
     * ```
     *
     * `bool bool_key = 7 [json_name = "boolKey"];`
     */
    public fun clearBoolKey() {
      _builder.clearBoolKey()
    }
    /**
     * ```
     * `bool_key` specifies a map key of type bool.
     * ```
     *
     * `bool bool_key = 7 [json_name = "boolKey"];`
     * @return Whether the boolKey field is set.
     */
    public fun hasBoolKey(): kotlin.Boolean {
      return _builder.hasBoolKey()
    }

    /**
     * ```
     * `int_key` specifies a map key of type int32, int64, sint32, sint64, sfixed32 or sfixed64.
     * ```
     *
     * `int64 int_key = 8 [json_name = "intKey"];`
     */
    public var intKey: kotlin.Long
      @kotlin.jvm.JvmName("getIntKey")
        get() = _builder.intKey
      @kotlin.jvm.JvmName("setIntKey")
        set(value) {
        _builder.intKey = value
      }
    /**
     * ```
     * `int_key` specifies a map key of type int32, int64, sint32, sint64, sfixed32 or sfixed64.
     * ```
     *
     * `int64 int_key = 8 [json_name = "intKey"];`
     */
    public fun clearIntKey() {
      _builder.clearIntKey()
    }
    /**
     * ```
     * `int_key` specifies a map key of type int32, int64, sint32, sint64, sfixed32 or sfixed64.
     * ```
     *
     * `int64 int_key = 8 [json_name = "intKey"];`
     * @return Whether the intKey field is set.
     */
    public fun hasIntKey(): kotlin.Boolean {
      return _builder.hasIntKey()
    }

    /**
     * ```
     * `uint_key` specifies a map key of type uint32, uint64, fixed32 or fixed64.
     * ```
     *
     * `uint64 uint_key = 9 [json_name = "uintKey"];`
     */
    public var uintKey: kotlin.Long
      @kotlin.jvm.JvmName("getUintKey")
        get() = _builder.uintKey
      @kotlin.jvm.JvmName("setUintKey")
        set(value) {
        _builder.uintKey = value
      }
    /**
     * ```
     * `uint_key` specifies a map key of type uint32, uint64, fixed32 or fixed64.
     * ```
     *
     * `uint64 uint_key = 9 [json_name = "uintKey"];`
     */
    public fun clearUintKey() {
      _builder.clearUintKey()
    }
    /**
     * ```
     * `uint_key` specifies a map key of type uint32, uint64, fixed32 or fixed64.
     * ```
     *
     * `uint64 uint_key = 9 [json_name = "uintKey"];`
     * @return Whether the uintKey field is set.
     */
    public fun hasUintKey(): kotlin.Boolean {
      return _builder.hasUintKey()
    }

    /**
     * ```
     * `string_key` specifies a map key of type string.
     * ```
     *
     * `string string_key = 10 [json_name = "stringKey"];`
     */
    public var stringKey: kotlin.String
      @kotlin.jvm.JvmName("getStringKey")
        get() = _builder.stringKey
      @kotlin.jvm.JvmName("setStringKey")
        set(value) {
        _builder.stringKey = value
      }
    /**
     * ```
     * `string_key` specifies a map key of type string.
     * ```
     *
     * `string string_key = 10 [json_name = "stringKey"];`
     */
    public fun clearStringKey() {
      _builder.clearStringKey()
    }
    /**
     * ```
     * `string_key` specifies a map key of type string.
     * ```
     *
     * `string string_key = 10 [json_name = "stringKey"];`
     * @return Whether the stringKey field is set.
     */
    public fun hasStringKey(): kotlin.Boolean {
      return _builder.hasStringKey()
    }
    public val subscriptCase: com.buf.validate.FieldPathElement.SubscriptCase
    @kotlin.jvm.JvmName("getSubscriptCase")
      get() = _builder.getSubscriptCase()

    public fun clearSubscript() {
      _builder.clearSubscript()
    }
  }
}
@kotlin.jvm.JvmSynthetic
public inline fun com.buf.validate.FieldPathElement.copy(block: `com.buf.validate`.FieldPathElementKt.Dsl.() -> kotlin.Unit): com.buf.validate.FieldPathElement =
  `com.buf.validate`.FieldPathElementKt.Dsl._create(this.toBuilder()).apply { block() }._build()

